{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://black-a-hw2/./src/audio.ts","webpack://black-a-hw2/./src/canvas.ts","webpack://black-a-hw2/./src/main.ts","webpack://black-a-hw2/./src/utils.ts"],"sourcesContent":["/* Author: Professor Andrew Wheeland (note from student Andrew Black, I just followed his tutorial!)\r\n * Since: unknown, utilized by Andrew Black 2/26/24\r\n * File: Audio.js\r\n * Purpose: audio.js is all about using AudioContext to work with audio for our canvas and web page\r\n */\r\n\r\n// NOTE: any comments that start with a number (e.g., // 1) are courtesy of Andrew Wheeland (some others, too!)\r\n\r\n// 1 - our WebAudio context, **we will export and make this public at the bottom of the file**\r\n\r\nlet audioCtx;\r\n\r\n// **These are \"private\" properties - these will NOT be visible outside of this module (i.e. file)**\r\n// 2 - WebAudio nodes that are part of our WebAudio audio routing graph\r\n\r\nlet element, sourceNode, analyserNode, gainNode, biquadFilter, lowShelfBiquadFilter;\r\n\r\n// 3 - here we are faking an enumeration\r\n\r\nconst DEFAULTS = Object.freeze({\r\n    gain: .5,\r\n    numSamples: 256\r\n});\r\n\r\n// 4 - create a new array of 8-bit integers (0-255)\r\n// this is a typed array to hold the audio frequency data\r\n\r\nlet audioData = new Uint8Array(DEFAULTS.numSamples / 2);\r\n\r\n// **Next are \"public\" methods - we are going to export all of these at the bottom of this file**\r\n\r\n/* SetupWebAudio: does the necessary setups for our audio to work on our webpage\r\n * Params: filePath: the filePath of the audio we will use\r\n*/\r\nconst setupWebaudio = (filePath) => {\r\n    // 1 - The || is because WebAudio has not been standardized across browsers yet\r\n    const AudioContext = window.AudioContext;\r\n    audioCtx = new AudioContext();\r\n\r\n    // 2 - this creates an <audio> element\r\n    element = new Audio();\r\n\r\n    // 3 - have it point at a sound file\r\n    loadSoundFile(filePath);\r\n\r\n    // 4 - create an a source node that points at the <audio> element\r\n    sourceNode = audioCtx.createMediaElementSource(element);\r\n\r\n    // 5 - create an analyser node\r\n    // note the UK spelling of \"Analyser\"\r\n    analyserNode = audioCtx.createAnalyser();\r\n\r\n    /*\r\n    // 6\r\n    We will request DEFAULTS.numSamples number of samples or \"bins\" spaced equally \r\n    across the sound spectrum.\r\n    \r\n    If DEFAULTS.numSamples (fftSize) is 256, then the first bin is 0 Hz, the second is 172 Hz, \r\n    the third is 344Hz, and so on. Each bin contains a number between 0-255 representing \r\n    the amplitude of that frequency.\r\n    */\r\n\r\n    // fft stands for Fast Fourier Transform\r\n    analyserNode.fftSize = DEFAULTS.numSamples;\r\n\r\n    // 7 - create a gain (volume) node\r\n    gainNode = audioCtx.createGain();\r\n    gainNode.gain.value = DEFAULTS.gain;\r\n\r\n\r\n    // 8 - create a biquadFilter (for bass and treble)\r\n    biquadFilter = audioCtx.createBiquadFilter();\r\n    biquadFilter.type = \"highshelf\";\r\n\r\n    lowShelfBiquadFilter = audioCtx.createBiquadFilter();\r\n    lowShelfBiquadFilter.type = \"lowshelf\";\r\n    // 1000 hertz\r\n    /* biquadFilter.frequency.setValueAtTime(1000, audioCtx.currentTime);\r\n    biquadFilter.gain.setValueAtTime(20, audioCtx.currentTime); */\r\n\r\n    // 9 - connect the nodes - we now have an audio graph\r\n    sourceNode.connect(biquadFilter);\r\n    biquadFilter.connect(lowShelfBiquadFilter);\r\n    lowShelfBiquadFilter.connect(analyserNode);\r\n    analyserNode.connect(gainNode);\r\n    gainNode.connect(audioCtx.destination);\r\n\r\n\r\n\r\n};\r\n\r\n/* LoadSoundFile: sets the source of our Audio element to the filepath\r\n * Params: filePath: filePath of audio file\r\n*/ \r\nconst loadSoundFile = (filePath) => {\r\n    element.src = filePath;\r\n};\r\n\r\n/* PlayCurrentSound: plays the audio element\r\n*/\r\nconst playCurrentSound = () => {\r\n    element.play();\r\n};\r\n\r\n/* PauseCurrentSound: pauses the audio element\r\n*/\r\nconst pauseCurrentSound = () => {\r\n    element.pause();\r\n};\r\n\r\n/* SetVolume: sets the volume output of the Audio based on the user's desired choice (Via slider in HTML)\r\n * Params: value: string that determines the output percentage\r\n */\r\nconst setVolume = (value) => {\r\n\r\n    // make sure that it's a Number rather than a String\r\n    value = Number(value);\r\n\r\n    gainNode.gain.value = value;\r\n\r\n};\r\n\r\n/* ToggleHighShelf: method that changes the treble of the audio output\r\n * Params: highShelf: bool \r\n */\r\nconst toggleHighshelf = (highshelf) => {\r\n    if (highshelf) {\r\n        biquadFilter.frequency.setValueAtTime(1000, audioCtx.currentTime);\r\n        biquadFilter.gain.setValueAtTime(-25, audioCtx.currentTime);\r\n    } else {\r\n        biquadFilter.gain.setValueAtTime(0, audioCtx.currentTime);\r\n    }\r\n}\r\n\r\n/* ToggleLowShelf: method that changes the bass of the audio output\r\n * Params: lowShelf: bool \r\n */\r\nconst toggleLowshelf = (lowshelf) => {\r\n    if (lowshelf) {\r\n        lowShelfBiquadFilter.frequency.setValueAtTime(1000, audioCtx.currentTime);\r\n        lowShelfBiquadFilter.gain.setValueAtTime(15, audioCtx.currentTime);\r\n    } else {\r\n        lowShelfBiquadFilter.gain.setValueAtTime(0, audioCtx.currentTime);\r\n    }\r\n}\r\n\r\n\r\nexport { audioCtx, setupWebaudio, playCurrentSound, pauseCurrentSound, loadSoundFile, setVolume, analyserNode, toggleHighshelf, toggleLowshelf };\r\n","/* Author: Andrew Black, with starter code from Professor Andrew Wheeland\r\n * Since: 2/26/24\r\n * File: canvas.js\r\n * Purpose: see below (written by Wheeland) NOTE: comments with a number or letter in front (e.g., // 3, // A) also by Wheeland\r\n/*\r\n    The purpose of this file is to take in the analyser node and a <canvas> element: \r\n      - the module will create a drawing context that points at the <canvas> \r\n      - it will store the reference to the analyser node\r\n      - in draw(), it will loop through the data in the analyser node\r\n      - and then draw something representative on the canvas\r\n      - maybe a better name for this file/module would be *visualizer.js* ?\r\n*/\r\n\r\nimport * as utils from './utils';\r\n\r\n//data to be used later\r\nlet ctx, canvasWidth, canvasHeight, gradient, analyserNode, audioData;\r\n\r\n// Interface for draw parameters\r\ninterface DrawParams {\r\n    showGradient: boolean | null;\r\n    showBars: boolean | null;\r\n    showCircles: boolean | null;\r\n    showTriangles: boolean | null;\r\n    showSquares: boolean | null;\r\n    showNoise: boolean | null;\r\n    showInvert: boolean | null;\r\n    showEmboss: boolean | null;\r\n    showLowshelf: boolean | null;\r\n    showHighshelf: boolean | null;\r\n    selectFrequency: boolean | null;\r\n  }\r\n\r\n//class Triangle. used as a class per mandate of HW requirements. Triangle is used to make Triangles appear on visualizer\r\nclass Triangle {\r\n\r\n    //values for start position and length of sides of triangles\r\n    x;\r\n    y;\r\n    length = 10;\r\n\r\n    /* SetStartPoint: function that determines the startpoint of the Triangle\r\n     * Params: canvasWidth, canvasHeight: the width and heigh of the canvas\r\n     */\r\n    setStartPoint(canvasWidth, canvasHeight) {\r\n        this.x = canvasWidth * 1 / 5;\r\n        this.y = canvasHeight * 2 / 5;\r\n    }\r\n\r\n    /* Update: function called to update values of Triangle, which in turn changes how its drawn\r\n     * Params: byteData: the number associated with the byte of current audio point; fillStyle: fillStyle of triangle\r\n    */\r\n    update(byteData, fillStyle) {\r\n\r\n        //numbers determined by trial error\r\n        byteData *= 5 / 10;\r\n\r\n        this.length = 10 + byteData;\r\n\r\n        //triangle would draw even if bytedata was 0. I couldn't figure out why, so this code solves that\r\n        if (byteData == 0) this.length = 0;\r\n\r\n        //draw a new triangle\r\n        this.draw(fillStyle);\r\n    }\r\n\r\n    /* Draw: draws the triangle based on specs in its class\r\n     * Params: fillStyle: fillStyle of triangle\r\n    */\r\n    draw(fillStyle) {\r\n\r\n        ctx.save();\r\n        ctx.beginPath();\r\n        ctx.fillStyle = fillStyle;\r\n        ctx.moveTo(this.x, this.y + this.length);\r\n        ctx.lineTo(this.x - this.length, this.y);\r\n        ctx.lineTo(this.x + this.length, this.y);\r\n        ctx.fill();\r\n        ctx.restore();\r\n\r\n    }\r\n}\r\n\r\n//class Square. used as a class per mandate of HW requirements. Square is used to make Squares appear on visualizer\r\nclass Square {\r\n\r\n    //values for start position and length of sides of triangles\r\n    x;\r\n    y;\r\n    length = 10;\r\n\r\n    /* SetStartPoint: function that determines the startpoint of the Square\r\n     * Params: canvasWidth, canvasHeight: the width and heigh of the canvas\r\n     */\r\n    setStartPoint(canvasWidth, canvasHeight) {\r\n        this.x = canvasWidth * 4 / 5;\r\n        this.y = canvasHeight * 1 / 2;\r\n    }\r\n\r\n    /* Update: function called to update values of Square, which in turn changes how its drawn\r\n    * Params: byteData: the number associated with the byte of current audio point; fillStyle: fillStyle of triangle\r\n   */\r\n    update(byteData, fillStyle) {\r\n\r\n        this.length = byteData;\r\n\r\n        //draw a new aquare\r\n        this.draw(fillStyle);\r\n\r\n    }\r\n\r\n    /* Draw: draws the square based on specs in its class\r\n     * Params: fillStyle: fillStyle of square\r\n    */\r\n    draw(fillStyle) {\r\n        ctx.save();\r\n        ctx.beginPath();\r\n        ctx.fillStyle = fillStyle;\r\n        ctx.rect(this.x - this.length / 2, this.y - this.length / 2, this.length, this.length);\r\n        ctx.fill();\r\n        ctx.restore();\r\n    }\r\n\r\n}\r\n\r\n//create new objects\r\nlet canvasTriangle = new Triangle();\r\nlet canvasSquare = new Square();\r\n\r\n/* SetupCanvas: sets up the canvas elements (such as width, height...)\r\n * Params: canvasElement: HTML context; analyserNodeRef: reference to the analyserNode from Audio object, which we will use in calculations to draw \r\n */\r\nconst setupCanvas = (canvasElement, analyserNodeRef) => {\r\n    // create drawing context\r\n    ctx = canvasElement.getContext(\"2d\");\r\n    canvasWidth = canvasElement.width;\r\n    canvasHeight = canvasElement.height;\r\n    // create a gradient that runs top to bottom\r\n    gradient = utils.getLinearGradient(ctx, 0, 0, 0, canvasHeight, [{ percent: .8, color: \"black\" }, { percent: 1, color: \"white\" }]);\r\n    // keep a reference to the analyser node\r\n    analyserNode = analyserNodeRef;\r\n    // this is the array where the analyser data will be stored\r\n    audioData = new Uint8Array(analyserNode.fftSize / 2);\r\n    //send our canvas data to our classes\r\n    canvasTriangle.setStartPoint(canvasWidth, canvasHeight);\r\n    canvasSquare.setStartPoint(canvasWidth, canvasHeight);\r\n};\r\n\r\n/* Draw: draws things to the canvas! \r\n * Params: params: objects holding truth values about what to draw\r\n*/\r\nconst draw = (params:DrawParams) => {\r\n    // 1 - populate the audioData array with the frequency data from the analyserNode\r\n    // notice these arrays are passed \"by reference\" \r\n\r\n    //check if the user has selected to visualize via frequency. if not, they MUST have chosen wavelength\r\n    //so get data via one of those two \r\n    if (params.selectFrequency) {\r\n        analyserNode.getByteFrequencyData(audioData);\r\n    } else {\r\n        analyserNode.getByteTimeDomainData(audioData); // waveform data\r\n    }\r\n\r\n    // 2 - draw background\r\n    ctx.save();\r\n    ctx.fillStyle = \"black\";\r\n    ctx.globalAlpha = .1;\r\n    ctx.fillRect(0, 0, canvasWidth, canvasHeight);\r\n    ctx.restore();\r\n\r\n    // 3 - draw gradient\r\n    if (params.showGradient) {\r\n        ctx.save();\r\n        ctx.fillStyle = gradient;\r\n        ctx.globalAlpha = .3;\r\n        ctx.fillRect(0, 0, canvasWidth, canvasHeight);\r\n        ctx.restore();\r\n    }\r\n\r\n\r\n    //call our objects to update them with the byte data if necessary\r\n    if (params.showTriangles) {\r\n        for (let i = 0; i < audioData.length; i++) {\r\n\r\n            //fillStyle numbers chosen by trial and error. Settled on these to match the Circles somewhat\r\n            let fillStyle = `rgba(${i / 10}, ${i / 5}, ${i}, 1)`;\r\n            canvasTriangle.update(audioData[i], fillStyle);\r\n        }\r\n    }\r\n    if (params.showSquares) {\r\n        for (let i = 0; i < audioData.length; i++) {\r\n\r\n            //fillStyle numbers chosen by trial and error. Settled on these to match the Circles somewhat\r\n            let fillStyle = `rgba(${i / 10}, ${i / 5}, ${i}, 1)`;\r\n            canvasSquare.update(audioData[i], fillStyle);\r\n        }\r\n    }\r\n    // 4 - draw bars \r\n    // based on params\r\n    if (params.showLowshelf) {\r\n\r\n        // values for creating our rectangles, or \"bars\".\r\n        let barSpacing = 1;\r\n        let margin = 5;\r\n        let screenWidthForBars = canvasWidth - (audioData.length * barSpacing) - margin * 2;\r\n        let barWidth = screenWidthForBars / audioData.length;\r\n        let barHeight = 400;\r\n        let topSpacing = 100;\r\n\r\n        ctx.save();\r\n        ctx.fillStyle = 'rgba(227, 174, 50,0.50)';\r\n        ctx.strokeStyle = 'rgba(0,0,0,0.50)';\r\n        //loop through the data and draw!\r\n        for (let i = 0; i < audioData.length; i++) {\r\n            ctx.fillRect(margin + i * (barWidth + barSpacing), topSpacing + 256 - audioData[i], barWidth, barHeight);\r\n            ctx.strokeRect(margin + i * (barWidth + barSpacing), topSpacing + 256 - audioData[i], barWidth, barHeight);\r\n        }\r\n        ctx.restore();\r\n\r\n\r\n\r\n    }\r\n\r\n    // draw in extra bars if our highshelf should be shown (treble)\r\n    if (params.showHighshelf) {\r\n\r\n\r\n        // values for creating our rectangles, or \"bars\".\r\n        let barSpacing = 6;\r\n        let margin = 3;\r\n        let screenWidthForBars = canvasWidth - (audioData.length * barSpacing) - margin * 2;\r\n        let barWidth = screenWidthForBars / audioData.length;\r\n        let barHeight = 400;\r\n        let topSpacing = -600;\r\n\r\n        ctx.save();\r\n        ctx.fillStyle = 'rgba(255,255,255,1)';\r\n        ctx.strokeStyle = 'rgba(255,255,255,0.50)';\r\n        //loop through the data and draw!\r\n        for (let i = 0; i < audioData.length; i++) {\r\n            ctx.fillRect(margin + i * (barWidth + barSpacing), topSpacing + 256 - audioData[i], barWidth, barHeight);\r\n            ctx.strokeRect(margin + i * (barWidth + barSpacing), topSpacing + 256 - audioData[i], barWidth, barHeight);\r\n        }\r\n        ctx.restore();\r\n\r\n\r\n    }\r\n\r\n\r\n    // draw in extra bars if our lowshelf should be shown (bass)\r\n    if (params.showBars) {\r\n\r\n\r\n        // values for creating our rectangles, or \"bars\".\r\n        let barSpacing = 4;\r\n        let margin = 5;\r\n        let screenWidthForBars = canvasWidth - (audioData.length * barSpacing) - margin * 2;\r\n        let barWidth = screenWidthForBars / audioData.length;\r\n        let barHeight = 200;\r\n        let topSpacing = 100;\r\n\r\n        ctx.save();\r\n        ctx.fillStyle = 'rgba(255,255,255,0.50)';\r\n        ctx.strokeStyle = 'rgba(0,0,0,0.50)';\r\n        //loop through the data and draw!\r\n        for (let i = 0; i < audioData.length; i++) {\r\n            ctx.fillRect(margin + i * (barWidth + barSpacing), topSpacing + 256 - audioData[i], barWidth, barHeight);\r\n            ctx.strokeRect(margin + i * (barWidth + barSpacing), topSpacing + 256 - audioData[i], barWidth, barHeight);\r\n        }\r\n        ctx.restore();\r\n    }\r\n\r\n    // 5 - draw circles\r\n    // based on params\r\n    if (params.showCircles) {\r\n\r\n        //some variables for creation of circle. most of this was done via tutorial and the numbers were mostly not chosen by myself\r\n        //for some fun, they could be messed with, but I actually enjoyed the default values\r\n        let maxRadius = canvasHeight / 4;\r\n        ctx.save();\r\n        ctx.globalAlpha = .5;\r\n        for (let i = 0; i < audioData.length; i++) {\r\n\r\n            let percent = audioData[i] / 255;\r\n\r\n            let circleRadius = percent * maxRadius;\r\n            // redish circles\r\n            ctx.beginPath();\r\n            ctx.fillStyle = utils.makeColor(255, 111, 111, .34 - percent / 3.0);\r\n            ctx.arc(canvasWidth / 2, canvasHeight / 2, circleRadius, 0, 2 * Math.PI, false);\r\n            ctx.fill();\r\n            ctx.closePath();\r\n\r\n            // blueish circles, bigger, more transparent\r\n            ctx.beginPath();\r\n            ctx.fillStyle = utils.makeColor(0, 0, 255, .10 - percent / 10.0);\r\n            ctx.arc(canvasWidth / 2, canvasHeight / 2, circleRadius * 1.5, 0, 2 * Math.PI, false);\r\n            ctx.fill();\r\n            ctx.closePath();\r\n\r\n            // yellow-ish circles, smaller\r\n            ctx.beginPath();\r\n            ctx.fillStyle = utils.makeColor(200, 200, 0, .5 - percent / 5.0);\r\n            ctx.arc(canvasWidth / 2, canvasHeight / 2, circleRadius * .5, 0, 2 * Math.PI, false);\r\n            ctx.fill();\r\n            ctx.closePath();\r\n\r\n            //restore path\r\n            ctx.restore();\r\n        }\r\n        ctx.restore();\r\n    }\r\n\r\n\r\n\r\n\r\n    // 6 - bitmap manipulation\r\n    // TODO: right now. we are looping though every pixel of the canvas (320,000 of them!), \r\n    // regardless of whether or not we are applying a pixel effect\r\n    // At some point, refactor this code so that we are looping though the image data only if\r\n    // it is necessary\r\n\r\n    // A) grab all of the pixels on the canvas and put them in the `data` array\r\n    // `imageData.data` is a `Uint8ClampedArray()` typed array that has 1.28 million elements!\r\n    // the variable `data` below is a reference to that array \r\n    let imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);\r\n    let data = imageData.data;\r\n    let length = data.length;\r\n    let width = imageData.width;\r\n\r\n\r\n    // emboss the screen if requested\r\n    if (params.showEmboss) {\r\n        //note we are stepping through *each* sub-pixel\r\n        for (let i = 0; i < length; i++) {\r\n            if (i % 4 == 3) continue; //skip alpha channel\r\n            data[i] = 127 + 2 * data[i] - data[i + 4] - data[i + width * 4];\r\n        }\r\n    }\r\n\r\n    // B) Iterate through each pixel, stepping 4 elements at a time (which is the RGBA for 1 pixel)\r\n    for (let i = 0; i < length; i += 4) {\r\n\r\n        // C) randomly change every 20th pixel to red\r\n        if (params.showNoise && Math.random() < .05) {\r\n            // data[i] is the red channel\r\n            // data[i+1] is the green channel\r\n            // data[i+2] is the blue channel\r\n            // data[i+3] is the alpha channel\r\n\r\n            // zero out the red and green and blue channels\r\n            // data[i] = data[i + 1] = data[i + 2] = 0;\r\n            // data[i] = 255;// make the red channel 100% red\r\n\r\n            // per assignment, changing the \"noise\" to be a different color than red\r\n            // currently shows yellow\r\n            // zero out the red and green and blue channels\r\n            data[i] = data[i + 1] = data[i + 2] = 0;\r\n\r\n            //create a yellow color for the noise\r\n            data[i] = 255;\r\n            data[i + 1] = 255;\r\n            data[i + 2] = 205;\r\n        } // end if\r\n\r\n        // invert the pixel colors if requested\r\n        if (params.showInvert) {\r\n            let red = data[i], green = data[i + 1], blue = data[i + 2];\r\n            data[i] = 255 - red; //set red\r\n            data[i + 1] = 255 - green; // set green\r\n            data[i + 2] = 255 - blue //set blue\r\n            //data[i+3] is the alpha, but we're leaving that alone\r\n        }\r\n\r\n\r\n    } // end for\r\n\r\n\r\n    // D) copy image data back to canvas\r\n    ctx.putImageData(imageData, 0, 0);\r\n};\r\n\r\nexport { setupCanvas, draw };\r\n","/* Author: Andrew Black, with Tutorials from Professor Andrew Wheeland\r\n * Since: 2/26/24\r\n * File: Main.ts\r\n * Purpose: main.ts is primarily responsible for hooking up the UI to the rest of the application.\r\n * it also sets up the main event loop and does any initializations needed\r\n */\r\n\r\nimport * as audio from './audio';\r\nimport * as canvas from './canvas';\r\nimport * as utils from './utils';\r\n\r\n// Interface for draw parameters\r\ninterface DrawParams {\r\n  showGradient: boolean | null;\r\n  showBars: boolean | null;\r\n  showCircles: boolean | null;\r\n  showTriangles: boolean | null;\r\n  showSquares: boolean | null;\r\n  showNoise: boolean | null;\r\n  showInvert: boolean | null;\r\n  showEmboss: boolean | null;\r\n  showLowshelf: boolean | null;\r\n  showHighshelf: boolean | null;\r\n  selectFrequency: boolean | null;\r\n}\r\n\r\n// Define the type for drawParams\r\ninterface DrawParams {\r\n  showGradient: boolean | null;\r\n  showBars: boolean | null;\r\n  showCircles: boolean | null;\r\n  showTriangles: boolean | null;\r\n  showSquares: boolean | null;\r\n  showNoise: boolean | null;\r\n  showInvert: boolean | null;\r\n  showEmboss: boolean | null;\r\n  showLowshelf: boolean | null;\r\n  showHighshelf: boolean | null;\r\n  selectFrequency: boolean | null;\r\n}\r\n\r\n// Params for drawing on canvas\r\nconst drawParams: DrawParams = {\r\n  showGradient: null,\r\n  showBars: null,\r\n  showCircles: null,\r\n  showTriangles: null,\r\n  showSquares: null,\r\n  showNoise: null,\r\n  showInvert: null,\r\n  showEmboss: null,\r\n  showLowshelf: null,\r\n  showHighshelf: null,\r\n  selectFrequency: null\r\n};\r\n\r\n// Arrays to keep track of trackNames and their data locations via a JSON file later\r\nlet trackNames: string[];\r\nlet trackLocations: string[];\r\n\r\n// Variable for the starting selection of the visualizer options (wavelength or frequency) loaded in via json\r\nlet startingVisualizerSelection: string;\r\n\r\n// Variable for the title of our application loaded in via json\r\nlet title: string;\r\n\r\n/* Init: does setup work for the rest of the program, notably instantiating setup for the canvas element, setting up the audio,\r\n * loading in the JSON file, and starting a loop for our canvas\r\n */\r\nconst init = () => {\r\n  console.log(\"init called\");\r\n  console.log(`Testing utils.getRandomColor() import: ${utils.getRandomColor()}`);\r\n\r\n  // Call our load json with a callback, firing the rest of the code (to ensure all the data in the json is loaded in before being used)\r\n  loadXmlXHR(() => {\r\n    // Load in audio\r\n    audio.setupWebaudio(trackLocations[0]);\r\n    // Hook up <canvas> element\r\n    let canvasElement = document.querySelector(\"canvas\"); \r\n    setupUI(canvasElement);\r\n    canvas.setupCanvas(canvasElement, audio.analyserNode);\r\n\r\n    \r\n    // Ensure initial state of dropdown \r\n    (document.querySelector(\"#track-select\") as HTMLSelectElement).value = trackLocations[0];\r\n    // Set default visualizer\r\n    (document.querySelector(\"#visualizer-select\") as HTMLSelectElement).value = startingVisualizerSelection;\r\n    // Set title \r\n    document.querySelector(\"title\")!.textContent = title;\r\n    // Start loop\r\n    loop();\r\n  });\r\n};\r\n\r\n/* loadXMLXHR: loads in JSON file containing data relevant to application (tracks, title of application, default values for checkboxes)\r\n * Params: callback: function to be called back, in this case the rest of init\r\n*/\r\nconst loadXmlXHR = (callback: () => void) => {\r\n  const url = \"data/av-data.json\";\r\n  const xhr = new XMLHttpRequest();\r\n\r\n  // Call the XMLHttpRequest onload event to get started\r\n  xhr.onload = (e) => {\r\n    // Log for debugging\r\n    console.log(`In onload - HTTP Status Code = ${(e.target as XMLHttpRequest).status}`);\r\n\r\n\r\n    // Load in json\r\n    const json = JSON.parse(xhr.responseText);\r\n\r\n    // Grab the json data for our arrays\r\n    trackLocations = json['Track Locations']; \r\n    trackNames = json['Tracks'];\r\n\r\n    // Get our truth table for our params, which holds the values for our checkboxes\r\n    const paramsTruthTable = json['Params Truth Table'];\r\n\r\n    paramsTruthTable.forEach((string: string) => {\r\n      // Split the strings by ':' to separate parameter name and value\r\n      const [paramName, paramValue] = string.split(':');\r\n\r\n      // Trim whitespaces from parameter name and value\r\n      const trimmedParamName = paramName.trim();\r\n      const trimmedParamValue = paramValue.trim();\r\n\r\n      // Convert each trimmed param value (by name, which is accurate with the json) to its true/false value\r\n      (drawParams as any)[trimmedParamName] = (trimmedParamValue === 'true' || trimmedParamValue === 'false') ? (trimmedParamValue === 'true') : trimmedParamValue;\r\n    });\r\n\r\n    // Set other vars equal to JSON values\r\n    startingVisualizerSelection = json['Default Visualizer State'];\r\n    title = json['Title'];\r\n\r\n    // Set the checked property of checkboxes based on drawParams values\r\n    (document.querySelector(\"#cb-noise\") as HTMLInputElement).checked = drawParams.showNoise as boolean;\r\n    (document.querySelector(\"#cb-bars\") as HTMLInputElement).checked = drawParams.showBars as boolean;\r\n    (document.querySelector(\"#cb-circles\") as HTMLInputElement).checked = drawParams.showCircles as boolean;\r\n    (document.querySelector(\"#cb-triangles\") as HTMLInputElement).checked = drawParams.showTriangles as boolean;\r\n    (document.querySelector(\"#cb-squares\") as HTMLInputElement).checked = drawParams.showSquares as boolean;\r\n    (document.querySelector(\"#cb-gradient\") as HTMLInputElement).checked = drawParams.showGradient as boolean;\r\n    (document.querySelector(\"#cb-invert\") as HTMLInputElement).checked = drawParams.showInvert as boolean;\r\n    (document.querySelector(\"#cb-emboss\") as HTMLInputElement).checked = drawParams.showEmboss as boolean;\r\n    (document.querySelector(\"#cb-lowshelf\") as HTMLInputElement).checked = drawParams.showLowshelf as boolean;\r\n    (document.querySelector(\"#cb-highshelf\") as HTMLInputElement).checked = drawParams.showHighshelf as boolean;\r\n\r\n    // Execute the callback function\r\n    callback();\r\n  };\r\n\r\n  // More debugging and necessary xml code\r\n  xhr.onerror = e => console.log(`In onerror - HTTP Status Code = ${(e.target as XMLHttpRequest).status}`);\r\n\r\n  xhr.open(\"GET\", url);\r\n  xhr.send();\r\n};\r\n\r\n/* SetupUI: sets up the UI elements for our Canvas. \r\n * Params: canvasElement: the HTML canvas element\r\n * NOTE: any commenting with a letter (e.g., // A) is courtesy of Andrew Wheeland\r\n */\r\nconst setupUI = (canvasElement: HTMLCanvasElement | null) => {\r\n  // A - hookup fullscreen button\r\n  const fsButton = document.querySelector(\"#fs-button\") as HTMLButtonElement;\r\n\r\n  // Add .onclick event to  fullscreen button\r\n  fsButton.onclick = e => {\r\n    console.log(\"goFullscreen() called\");\r\n\r\n    // First use of an imported method, utils.goFullScreen makes the screen go... full\r\n    utils.goFullscreen(canvasElement!);\r\n  };\r\n\r\n  // B - hookup for play button\r\n  const playButton = document.querySelector(\"#play-button\") as HTMLButtonElement;\r\n\r\n  // Add .onclick event to play button\r\n  playButton.onclick = e => {\r\n\r\n    // Check if context is in suspended state (Autoplay policy)\r\n    if (audio.audioCtx.state == \"suspended\") {\r\n      audio.audioCtx.resume();\r\n    }\r\n\r\n    // Debug information\r\n    console.log(`audioCtx.state after = ${audio.audioCtx.state}`);\r\n\r\n    // If track is currently paused, play it\r\n    if (playButton.dataset.playing == \"no\") {\r\n\r\n      audio.playCurrentSound();\r\n\r\n      // CSS will set state to \"Pause\"\r\n      playButton.dataset.playing = \"yes\";\r\n\r\n      // Else if track IS playing, pause it!\r\n    } else {\r\n      audio.pauseCurrentSound();\r\n\r\n      // CSS will set state to \"Play\"\r\n      playButton.dataset.playing = \"no\";\r\n    }\r\n  };\r\n\r\n  // C - hookup volume slider & label\r\n  let volumeSlider = document.querySelector(\"#volume-slider\") as HTMLInputElement;\r\n  let volumeLabel = document.querySelector(\"#volume-label\");\r\n\r\n    // Add .oninput event to slider\r\n  volumeSlider.oninput = e => {\r\n    // Set the gain\r\n    audio.setVolume(Number((e.target as HTMLInputElement).value));\r\n    // Update value of label to match that of slider\r\n    volumeLabel.innerHTML = Math.round((Number((e.target as HTMLInputElement).value) / 2 * 100)).toString();\r\n\r\n  };\r\n  // Set the value of label to match initial value of slider\r\n  volumeSlider.dispatchEvent(new Event(\"input\"));\r\n\r\n  // D - hookup track <select>\r\n  let trackSelect = document.querySelector(\"#track-select\") as HTMLSelectElement;\r\n  // Add .onchange event to <select>\r\n  trackSelect.onchange = e => {\r\n    audio.loadSoundFile((e.target as HTMLSelectElement).value);\r\n    // Pause the current track if it is playing\r\n    if (playButton.dataset.playing == \"yes\") {\r\n      playButton.dispatchEvent(new MouseEvent(\"click\"));\r\n    }\r\n  };\r\n\r\n  // Hookup the visualizer selector, which in short changes the visuals based on how the data from audio is read\r\n  let visualizerSelect = document.querySelector(\"#visualizer-select\") as HTMLSelectElement;\r\n\r\n  // Set the onclick to change the value of the selectFrequency\r\n  visualizerSelect.onchange = e => {\r\n    drawParams.selectFrequency = !drawParams.selectFrequency;\r\n  };\r\n\r\n  // E - setup checkboxes\r\n  // Set onclicks of our checkboxes to modify values of drawParams object\r\n  (document.querySelector(\"#cb-bars\") as HTMLInputElement).onclick = e => {\r\n    drawParams.showBars = (e.target as HTMLInputElement).checked;\r\n  };\r\n\r\n  (document.querySelector(\"#cb-circles\") as HTMLInputElement).onclick = e => {\r\n    drawParams.showCircles = (e.target as HTMLInputElement).checked;\r\n  };\r\n\r\n  (document.querySelector(\"#cb-triangles\") as HTMLInputElement).onclick = e => {\r\n    drawParams.showTriangles = (e.target as HTMLInputElement).checked;\r\n  };\r\n\r\n  (document.querySelector(\"#cb-squares\") as HTMLInputElement).onclick = e => {\r\n    drawParams.showSquares = (e.target as HTMLInputElement).checked;\r\n  };\r\n\r\n  (document.querySelector(\"#cb-gradient\") as HTMLInputElement).onclick = e => {\r\n    drawParams.showGradient = (e.target as HTMLInputElement).checked;\r\n  };\r\n\r\n  (document.querySelector(\"#cb-noise\") as HTMLInputElement).onclick = e => {\r\n    drawParams.showNoise = (e.target as HTMLInputElement).checked;\r\n  };\r\n\r\n  (document.querySelector(\"#cb-emboss\") as HTMLInputElement).onclick = e => {\r\n    drawParams.showEmboss = (e.target as HTMLInputElement).checked;\r\n  };\r\n\r\n  (document.querySelector(\"#cb-invert\") as HTMLInputElement).onclick = e => {\r\n    drawParams.showInvert = (e.target as HTMLInputElement).checked;\r\n  };\r\n\r\n  (document.querySelector(\"#cb-lowshelf\") as HTMLInputElement).onclick = e => {\r\n    drawParams.showLowshelf = (e.target as HTMLInputElement).checked;\r\n    audio.toggleLowshelf(drawParams.showLowshelf);\r\n  };\r\n\r\n  (document.querySelector(\"#cb-highshelf\") as HTMLInputElement).onclick = e => {\r\n    drawParams.showHighshelf = (e.target as HTMLInputElement).checked;\r\n    audio.toggleHighshelf(drawParams.showHighshelf);\r\n  };\r\n}; \r\n\r\n/* Loop: this function calls a continuous loop that is responsible for our visualizer continuing to update\r\n * Note that the setTimeout function prevents the canvas from updating more than 60 FPS.\r\n * canvas.draw() is an external function that starts the drawing process, and takes in all those params\r\n * we grabbed from the JSON file\r\n */\r\nconst loop = () => {\r\n  setTimeout(loop);\r\n  canvas.draw(drawParams);\r\n};\r\n\r\ninit();\r\n","/* Author: Professor Andrew Wheeland (note from student Andrew Black, I just followed his tutorial!)\r\n * Since: unknown, utilized by Andrew Black 2/26/24\r\n * Purpose: utils.js is all about giving our other functions ways to utilize randomization and the ability to go fullscreen\r\n */\r\n\r\n/* MakeColor: returns a RGB value based on params\r\n * Params: red, green, blue, alpha: values for RGBA color creation (alpha defaults to 1 if not specified);\r\n * Returns: string used for the canvas that utlizes those values\r\n */\r\nconst makeColor = (red, green, blue, alpha = 1) => {\r\n  return `rgba(${red},${green},${blue},${alpha})`;\r\n};\r\n\r\n/* GetRandom: returns a random number based on a min and max\r\n * Params: min, max: the minimum and maxmium values used in calculation\r\n * Returns: number\r\n */\r\nconst getRandom = (min, max) => {\r\n  return Math.random() * (max - min) + min;\r\n};\r\n\r\n/* GetRandomColor: returns a random RGBA value\r\n * Returns: string used for the canvas that utlizes those values\r\n */\r\nconst getRandomColor = () => {\r\n  // so that colors are not too bright or too dark \r\n  const floor = 35;\r\n  const getByte = () => getRandom(floor, 255 - floor);\r\n  return `rgba(${getByte()},${getByte()},${getByte()},1)`;\r\n};\r\n\r\n/* GetLinearGradient: returns linear gradient for the canvas\r\n * Params: ctx: the canvas; startX, startY, endX, endY: the X/Y positions for beginning and end of gradient creation,\r\n * colorStops: the percentage of color we'd like at each stop (e.g., [{ percent: .8, color: \"black\" }, { percent: 1, color: \"white\" }])\r\n * Returns: liner gradient object\r\n */\r\nconst getLinearGradient = (ctx, startX, startY, endX, endY, colorStops) => {\r\n  let lg = ctx.createLinearGradient(startX, startY, endX, endY);\r\n  for (let stop of colorStops) {\r\n    lg.addColorStop(stop.percent, stop.color);\r\n  }\r\n  return lg;\r\n};\r\n\r\n/* GoFullScreen: allows the web page to utilize a fullscreen function\r\n * Better understanding at: https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API\r\n*/\r\nconst goFullscreen = (element) => {\r\n  if (element.requestFullscreen) {\r\n    element.requestFullscreen();\r\n  } else if (element.mozRequestFullscreen) {\r\n    element.mozRequestFullscreen();\r\n  } else if (element.mozRequestFullScreen) { // camel-cased 'S' was changed to 's' in spec\r\n    element.mozRequestFullScreen();\r\n  } else if (element.webkitRequestFullscreen) {\r\n    element.webkitRequestFullscreen();\r\n  }\r\n  // .. and do nothing if the method is not supported\r\n};\r\n\r\nexport { makeColor, getRandomColor, getLinearGradient, goFullscreen };"],"names":["audioCtx","sourceNode","analyserNode","gainNode","biquadFilter","lowShelfBiquadFilter","ctx","canvasWidth","canvasHeight","gradient","trackLocations","startingVisualizerSelection","title","callback","xhr","getByte","DEFAULTS","Object","freeze","gain","numSamples","loadSoundFile","Uint8Array","filePath","src","makeColor","red","green","blue","alpha","length","setStartPoint","this","x","y","update","byteData","fillStyle","draw","save","beginPath","moveTo","lineTo","fill","restore","rect","canvasTriangle","Triangle","canvasSquare","Square","drawParams","showGradient","showBars","showCircles","showTriangles","showSquares","showNoise","showInvert","showEmboss","showLowshelf","showHighshelf","selectFrequency","loop","setTimeout","params","getByteFrequencyData","getByteTimeDomainData","globalAlpha","fillRect","i","barSpacing","margin","barWidth","barHeight","topSpacing","strokeStyle","strokeRect","maxRadius","percent","circleRadius","arc","Math","PI","closePath","imageData","getImageData","data","width","random","putImageData","console","log","AudioContext","window","Audio","createMediaElementSource","createAnalyser","fftSize","createGain","value","createBiquadFilter","type","connect","destination","canvasElement","document","querySelector","onclick","e","element","requestFullscreen","mozRequestFullscreen","mozRequestFullScreen","webkitRequestFullscreen","playButton","state","resume","dataset","playing","play","pause","volumeSlider","volumeLabel","oninput","Number","target","innerHTML","round","toString","dispatchEvent","Event","onchange","MouseEvent","checked","frequency","setValueAtTime","currentTime","setupUI","analyserNodeRef","getContext","height","startX","startY","endX","endY","colorStops","lg","createLinearGradient","color","addColorStop","textContent","XMLHttpRequest","onload","status","json","JSON","parse","responseText","forEach","string","split","paramName","paramValue","trimmedParamName","trim","trimmedParamValue","onerror","open","send"],"sourceRoot":""}